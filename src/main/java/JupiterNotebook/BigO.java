package JupiterNotebook;

public class BigO {

    //시간복잡도에 대해 알게 된점 정리
    /**
     * 알고리즘 복잡도?
     * 어떠한 문제를 풀 때 다양한 알고리즘을 적용해서 해결할 수 있는데
     * 해결 할 때 복잡도라는 것을 정의를 해서 최적의 알고리즘을 계산한다.
     * 복잡도는 크개 2가지가 존재.
     * 1. 시간복잡도 : 알고리즘의 실행 속도.
     * 2. 공간복잡도 : 알고리즘이 사용하는 메모리 사이즈.
     *
     * 알고리즘 시간 복잡도의 주요 요소
     *  반복문의 의해 좌우됨.
     *
     * 알고리즘의 성능 표기법
     * 1.BIG O 표기법 : 최악으로 걸리는 시간을 표시할 때 (주로 빅오표기법으로 표현을 함 Why? 최악의 상황이라도 이 정도의 성능을 보장함을 의미.)
     * 2.오메가 표기법 : 최상의 실행시간
     * 3.세타 표기법 : 평균 실행시간
     *
     * 대문자 O 표기법
     * 입력 n에 따라서 결정되는 시간 복잡도 함수
     *  상수는 O(1)로 표기.
     *  상수는 크게 영향을 끼치지 않음.
    * */

    /**
     * 복잡도 예제
     * 알고리즘1: 1부터 n까지의 합을 구하는 알고리즘1
     * 합을 기록할 변수를 만들고 0을 저장
     * n을 1부터 1씩 증가하면서 반복
     * 반복문 안에서 합을 기록할 변수에 1씩 증가된 값을 더함
     * 반복이 끝나면 합을 출력
     * */

    public int sumData(int n){
        int sum = 0;    //합을 기록할 변수를 만들고 0을 저장

        for(int i=1; i<=n; i++){
            sum+=i;
        }
        return sum;
    }
    //  O(n) Why? 상수n에 따라서 복잡도가 증가하기 때문에

    public int sumData2(int n){
       int sum = 0;

       sum = n * (n+1) / 2;

        return sum;
    }
    // O(1) Why? N이 증가됨에 따라서 반복횟수가 늘어나는게 아니기 때문!

    /*
    * 이때 알고리즘의 성능이 어떤게 더 좋은가?
    * O(n) < O(1)으로 두번째 알고리즘이 더 성능이 우수함!
    * */

    public static void main(String[] args){
        BigO test = new BigO();

        System.out.println(test.sumData(10));

        System.out.println(test.sumData2(10));
    }
}
